<html>
<head>
    <script src="js/pixi.min.js"></script>
    <script src="js/planck.min.js"></script>
    <script src="js/utils.js"></script>
    <script src="base-config.js"></script>
    <script src="custom-config.js"></script>
</head>
<body>
<script>
    const
        {
            Application,
            Graphics,
            Container,
            Sprite,
            Texture,
            Text,
            TextStyle,
            loader,
        } = PIXI,
        TilingSprite = PIXI.extras.TilingSprite,
        resources = loader.resources,
        {
            Vec2,
            World,
            Edge,
            Circle,
        } = planck;

    function physicsPos2renderPos(pp) {
        return {
            x: pp.x * config.meter2pixel,
            y: config.designHeight - pp.y * config.meter2pixel
        }
    }

    function renderPos2PhysicsPos(rp) {
        return Vec2(
            rp.x * config.pixel2meter,
            (config.designHeight - rp.y) * config.pixel2meter
        );
    }

    class App {
        init() {
            document.body.style.margin = "0";

            let resolution;

            let wwhRatio = window.innerWidth / window.innerHeight;
            let dwhRatio = config.designWidth / config.designHeight;
            if (wwhRatio >= dwhRatio) {
                resolution = window.innerHeight / config.designHeight;
                this.appWidth = config.designWidth;
                this.appHeight = config.designHeight;
            } else {
                resolution = window.innerWidth / config.designWidth;
                this.appWidth = config.designWidth;
                this.appHeight = config.designWidth / window.innerWidth * window.innerHeight;
            }

            this.app = new Application({
                width: this.appWidth,
                height: this.appHeight,
                antialiasing: true,
                transparent: false,
                resolution: resolution,
                backgroundColor: config.backgroundColor
            });
            document.body.appendChild(this.app.view);

            this.app.view.style.position = "absolute";
            this.app.view.style.left = (window.innerWidth - this.app.view.offsetWidth) / 2 + "px";
            this.app.view.style.top = (window.innerHeight - this.app.view.offsetHeight) / 2 + "px";

            new StartScene().init(this);
        }

        getScenesContainer() {
            return this.app.stage;
        }

        getSceneWidth() {
            return this.appWidth;
        }

        getSceneHeight() {
            return this.appHeight;
        }

        addTicker(handler) {
            this.app.ticker.add(handler);
        }
    }

    class StartScene {
        init(app) {
            this.app = app;
            this.app.startScene = this;

            this.sceneContainer = new Container();
            app.getScenesContainer().addChild(this.sceneContainer);

            let textContainer = new Container();
            textContainer.position.set(app.getSceneWidth() / 2,
                (app.getSceneHeight() - 50 * config.mapList.length) / 2);
            this.sceneContainer.addChild(textContainer);

            let textStyle = new TextStyle({
                fontSize: 50,
                fill: "white",
            });
            config.mapList.forEach((map, i) => {
                let text = new Text(`MAP-${i}: ${map.showName}`, textStyle);
                text.position.set(-text.width / 2, text.height * i);
                textContainer.addChild(text);
                text.interactive = true;
                text.buttonMode = true;
                text.on("pointerdown", () => this.onClickMapText(i));
            });
        }

        onClickMapText(mapIndex) {
            this.sceneContainer.visible = false;
            if (this.gameScene === undefined) {
                this.gameScene = new GameScene();
                this.gameScene.init(this.app);
            }
            this.gameScene.startGame(mapIndex);
        }

        show() {
            this.sceneContainer.visible = true;
        }
    }

    class GameScene {
        init(app) {
            this.app = app;
            this.app.gameScene = this;

            this.sceneContainer = new Container();
            app.getScenesContainer().addChild(this.sceneContainer);

            this.offsetContainer = new Container();
            let scale = app.getSceneHeight() / config.designHeight;
            this.offsetContainer.position.x = (app.getSceneWidth() - config.designWidth * scale) / 2;
            this.offsetContainer.scale.set(scale, scale);
            this.sceneContainer.addChild(this.offsetContainer);

            this.camera = new Container();
            this.offsetContainer.addChild(this.camera);

            this.createBottomMask();

            this.createFPSMessage();

            window.addEventListener("keydown", this.onKeydown.bind(this));

            this.offsetContainer.interactive = true;
            this.offsetContainer.buttonMode = true;
            this.offsetContainer.on("pointerdown", this.onClickGameContainer.bind(this));

            this.gameStatus = "end";
            this.gameLoopFunc = this.pause.bind(this);
            this.app.addTicker(this.gameLoop.bind(this));
        }

        startGame(mapIndex) {
            this.camera.removeChildren();

            this.sceneContainer.visible = true;
            this.map = config.mapList[mapIndex];

            let texturePathList = values(this.map.texture)
                .concat([
                    config.mapPathBasePath + this.map.sceneName + ".scene",
                    config.bikeImagePath,
                    config.finalFlagImagePath,
                ]);

            texturePathList = texturePathList.filter(path => resources[path] === undefined);

            loader
                .add(texturePathList)
                .load(this.onLoaded.bind(this));
        }

        onLoaded() {
            this.bikeVelocity = this.map.bikeVelocity || config.bikeVelocity;
            this.gravity = this.map.gravity || config.gravity;
            this.jumpForce = this.map.jumpForce || config.jumpForce;

            this.world = new World({gravity: Vec2(0, this.gravity)});

            this.world.on('begin-contact', this.onBeginContact.bind(this));

            this.createBg();

            this.gameContainer = new Container();
            this.camera.addChild(this.gameContainer);

            let pathList = this.getRoadPathList();

            let lastPath = getLast(pathList);
            this.finalPoint = {
                x: (lastPath[lastPath.length - 2] + lastPath[lastPath.length - 4]) / 2,
                y: (lastPath[lastPath.length - 1] + lastPath[lastPath.length - 3]) / 2,
            };

            pathList.forEach(path => this.createRoad(path, this.map.texture.side, this.map.texture.top));
            this.createFinalFlag();

            this.createRider(config.bikeImagePath, pathList);

            this.gameStatus = "play";
            this.gameLoopFunc = this.play.bind(this);
            this.bikeBody.setLinearVelocity(Vec2(this.bikeVelocity, 0));
        }

        onBeginContact(contact) {
            if (contact.getFixtureA().getBody() === this.bikeBody
                || contact.getFixtureB().getBody() === this.bikeBody) {
                this.jumping = false;
                this.jumpCount = 0;
            }
        }

        onClickGameContainer() {
            if (this.gameStatus === "play") {
                if (this.jumpCount < config.jumpMaxCount) {
                    let velocity = this.bikeBody.getLinearVelocity();
                    this.bikeBody.setLinearVelocity(Vec2(velocity.x, 0));
                    this.bikeBody.applyForceToCenter(Vec2(0, this.jumpForce));
                    this.bikeSprite.rotation = angle2radius(config.bikeJumpingRotation);
                    this.jumping = true;
                    this.jumpCount += 1;
                }
            }
        }

        onKeydown(event) {
            switch (event.code) {
                case "ArrowUp": {
                    this.onClickGameContainer();
                    break;
                }
                case "Space": {
                    if (this.gameStatus === "play") {
                        this.gameLoopFunc = this.pause.bind(this);
                        this.gameStatus = "pause";
                    } else if (this.gameStatus === "pause") {
                        this.gameLoopFunc = this.play.bind(this);
                        this.gameStatus = "play";
                    }
                    break;
                }
            }
        }

        getRoadPathList() {
            let json = JSON.parse(resources[config.mapPathBasePath + this.map.sceneName + ".scene"].data);
            return json.child.map(data =>
                data.props.points.split(",").map((intStr, i) => {
                    let value = parseInt(intStr);
                    if (i % 2 === 0) {
                        value += data.props.x;
                    } else {
                        value += data.props.y;
                    }
                    return value;
                })
            );
        }

        createBg() {
            let bg = this.map.texture.bg;
            for (let i = 0; i < bg.length; i++) {
                let container = new Container();
                this.camera.addChild(container);
                let texturePath = bg[i];
                let texture = resources[texturePath].texture;
                let scale = config.designHeight / texture.height;
                for (let i = 0; i < 2; i++) {
                    let sprite = new Sprite(texture);
                    sprite.scale.set(scale, scale);
                    sprite.position.set(i * texture.width * scale, 0);
                    container.addChild(sprite);
                }
            }
        }

        createRoad(path, sideTexturePath, topTexturePath) {
            path = [path[0], config.cliffBottomY]
                .concat(path)
                .concat([path[path.length - 2], config.cliffBottomY]);

            let road = new Container();

            let sideTexture = resources[sideTexturePath].texture;
            let sideRect = getPathRect(path);
            let side = new TilingSprite(sideTexture, sideRect.width, sideRect.height);
            side.position.set(sideRect.x, sideRect.y);
            road.addChild(side);

            let topTexture = resources[topTexturePath].texture;
            let length = path.length;
            for (let i = 2; i < length - 4; i += 2) {
                let sp = {
                        x: path[i],
                        y: path[i + 1]
                    },
                    ep = {
                        x: path[i + 2],
                        y: path[i + 3]
                    };
                let topWidth = calcPointDistance(sp, ep);
                let top = new TilingSprite(topTexture, topWidth, topTexture.height);
                top.position.set(sp.x, sp.y);
                top.rotation = calcRadius(sp, ep);
                road.addChild(top);
            }

            let edgeList = [
                {
                    sp: {x: path[0], y: path[1]},
                    ep: {x: path[2], y: path[3]},
                },
                {
                    sp: {x: path[path.length - 4], y: path[path.length - 3]},
                    ep: {x: path[path.length - 2], y: path[path.length - 1]},
                },
            ];
            edgeList.forEach(({sp, ep}) => {
                let edgeWidth = Math.abs(sp.y - ep.y);

                let canvas = document.createElement('canvas');
                canvas.width = `${edgeWidth}`;
                canvas.height = `${config.edgeHeight}`;
                let ctx = canvas.getContext('2d');
                let gradient = ctx.createLinearGradient(0, 0, 0, config.edgeHeight);
                config.edgeColorStop.forEach(({offset, opacity}) => gradient.addColorStop(offset, `rgba(0, 0, 0, ${opacity})`));
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, edgeWidth, config.edgeHeight);

                let edgeTexture = Texture.fromCanvas(canvas);
                let edge = new Sprite(edgeTexture);
                edge.position.set(sp.x, sp.y);
                edge.rotation = calcRadius(sp, ep);
                road.addChild(edge);

            });

            let mask = new Graphics();
            mask.beginFill();
            mask.drawPolygon(path);
            mask.endFill();
            road.mask = mask;

            road.cacheAsBitmap = true;

            this.gameContainer.addChild(road);

            path = path.map((value, i) => {
                if (i % 2 === 1) {
                    value = config.designHeight - value;
                }
                return value * config.pixel2meter;
            });
            let body = this.world.createBody();
            for (let i = 0; i < length - 4; i += 2) {
                let sp = {
                        x: path[i],
                        y: path[i + 1]
                    },
                    ep = {
                        x: path[i + 2],
                        y: path[i + 3]
                    };
                body.createFixture(Edge(Vec2(sp.x, sp.y), Vec2(ep.x, ep.y)), {
                    density: 0,
                    friction: 1,
                });
            }
        }

        createFinalFlag() {
            let sprite = new Sprite(resources[config.finalFlagImagePath].texture);
            sprite.anchor.set(0.5, 1);
            sprite.scale.set(0.5, 0.5);
            sprite.position.set(this.finalPoint.x, this.finalPoint.y);
            this.gameContainer.addChild(sprite);
        }

        createRider(texturePath, pathList) {
            this.bikeSprite = new Sprite(resources[texturePath].texture);
            this.bikeSprite.anchor.set(0.5, 0.5);
            this.bikeSprite.scale.set(config.riderScale, config.riderScale);

            this.bikeBody = this.world.createDynamicBody();
            this.bikeBody.createFixture(Circle(config.bikeRadius), {
                density: 1,
                friction: 1,
            });
            let firstPoint = renderPos2PhysicsPos({x: pathList[0][0] + config.bikeLeftMargin, y: pathList[0][1]});
            firstPoint.x += config.bikeRadius;
            firstPoint.y += config.bikeRadius;
            this.bikeBody.setPosition(firstPoint);

            this.gameContainer.addChild(this.bikeSprite);
            this.jumpCount = 0;
        }

        createBottomMask() {
            let canvas = document.createElement('canvas');
            canvas.width = `${config.designWidth}`;
            canvas.height = `${config.maskHeight}`;
            let ctx = canvas.getContext('2d');
            let gradient = ctx.createLinearGradient(0, 0, 0, config.maskHeight);
            config.maskColorStop.forEach(({offset, opacity}) => gradient.addColorStop(offset, `rgba(0, 0, 0, ${opacity})`));
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, config.designWidth, config.maskHeight);

            let texture = Texture.fromCanvas(canvas);
            let sprite = new Sprite(texture);
            sprite.anchor.set(0, 1);
            sprite.position.set(0, config.designHeight);
            this.offsetContainer.addChild(sprite);
        }

        createFPSMessage() {
            let style = new TextStyle({
                fill: "white",
                stroke: '#ff3300',
                strokeThickness: 1,
            });
            this.fpsMessage = new Text("FPS:0", style);
            this.fpsMessage.anchor.set(0, 0);
            this.fpsMessage.position.set(0, 0);
            this.sceneContainer.addChild(this.fpsMessage);
        }

        gameLoop(delta) {
            this.gameLoopFunc(delta);
        }

        play(delta) {
            this.fpsMessage.text = `FPS:${Math.floor(delta * 60)}`;

            this.world.step(delta / config.fps);

            let velocity = this.bikeBody.getLinearVelocity();
            let bikePhysicsPos = this.bikeBody.getPosition();

            let bikeRenderPos = physicsPos2renderPos(bikePhysicsPos);
            this.bikeSprite.position.set(bikeRenderPos.x, bikeRenderPos.y);

            if (!this.jumping) {
                this.bikeSprite.rotation = -Math.atan(velocity.y / this.bikeVelocity);
            }

            if (this.gameStatus === "play"
                && (velocity.x <= 0 || bikePhysicsPos.y < config.bikeGameOverHeight)) {
                this.endCount = this.endCount || 0;
                this.endCount++;
                if (this.endCount >= 7) {
                    this.endCount = 0;
                    this.gameStatus = "end";

                    if (velocity.x <= 0) {
                        this.bikeBody.setLinearVelocity(Vec2(0, 0));
                        this.bikeBody.setAngularVelocity(config.bikeGameOverAngularVelocity);
                        this.bikeBody.applyForceToCenter(Vec2(-2500, 5000));
                    }

                    if (this.app.gameOverScene === undefined) {
                        new GameOverScene().init(this.app);
                    }
                    this.app.gameOverScene.show();
                }
            }

            if (this.gameStatus === "play"
                && bikePhysicsPos.x > renderPos2PhysicsPos(this.finalPoint).x) {
                this.gameStatus = "win";
                if (this.app.gameOverScene === undefined) {
                    new GameOverScene().init(this.app);
                }
                this.app.gameOverScene.show("Game Win");
            }

            if (this.gameStatus === "play") {
                this.bikeBody.setLinearVelocity(Vec2(this.bikeVelocity, velocity.y));

                let oldCameraX = this.camera.position.x;
                let oldCameraY = this.camera.position.y;

                this.camera.position.x = config.bikeLeftMargin - this.bikeSprite.position.x;

                let bikeY = this.camera.position.y + this.bikeSprite.position.y;
                if (bikeY < config.bikeCameraMinY) {
                    this.camera.position.y = config.bikeCameraMinY - this.bikeSprite.position.y;
                } else if (bikeY > config.bikeCameraMaxY) {
                    this.camera.position.y = config.bikeCameraMaxY - this.bikeSprite.position.y;
                }

                let cameraMoveX = this.camera.position.x - oldCameraX;
                let cameraMoveY = this.camera.position.y - oldCameraY;

                this.camera.children.forEach((child, index) => {
                    child.position.x -= cameraMoveX * this.map.horizontalParallaxDepth[index];
                    child.position.y -= cameraMoveY * this.map.verticalParallaxDepth[index];
                });
            }
        }

        pause() {
        }

        clearGame() {
            this.sceneContainer.visible = false;
        }

        restart() {
            let pathList = this.getRoadPathList();
            let firstPoint = renderPos2PhysicsPos({x: pathList[0][0] + config.bikeLeftMargin, y: pathList[0][1]});
            firstPoint.x += config.bikeRadius;
            firstPoint.y += config.bikeRadius;
            this.bikeBody.setPosition(firstPoint);
            this.bikeBody.setAngularVelocity(0);
            this.bikeBody.setLinearVelocity(Vec2(this.bikeVelocity, 0));
            this.world.clearForces();
            this.gameStatus = "play";
        }
    }

    class GameOverScene {
        init(app) {
            this.app = app;
            this.app.gameOverScene = this;

            this.sceneContainer = new Container();
            this.app.getScenesContainer().addChild(this.sceneContainer);

            let mask = new Graphics();
            mask.beginFill(0x000000, 0.5);
            mask.drawRect(0, 0, this.app.getSceneWidth(), this.app.getSceneHeight());
            mask.endFill();
            this.sceneContainer.addChild(mask);

            let textContainer = new Container();
            textContainer.position.set(app.getSceneWidth() / 2,
                (app.getSceneHeight() - 50 * 2 + 80) / 2);
            this.sceneContainer.addChild(textContainer);

            let textStyle = new TextStyle({
                fontSize: 80,
                fill: "red",
            });

            this.gameOverText = new Text("Game Over", textStyle);
            this.gameOverText.position.set(-this.gameOverText.width / 2, 0);
            textContainer.addChild(this.gameOverText);

            textStyle = new TextStyle({
                fontSize: 50,
                fill: "white",
            });

            let selectMapText = new Text("Select Map", textStyle);
            selectMapText.position.set(-selectMapText.width / 2, 80);
            textContainer.addChild(selectMapText);
            selectMapText.interactive = true;
            selectMapText.buttonMode = true;
            selectMapText.on("pointerdown", () => this.onClickSelectMapText());

            let restartText = new Text("Restart", textStyle);
            restartText.position.set(-restartText.width / 2, 80 + 50);
            textContainer.addChild(restartText);
            restartText.interactive = true;
            restartText.buttonMode = true;
            restartText.on("pointerdown", () => this.onClickRestartText());
        }

        show(msg) {
            this.sceneContainer.visible = true;
            msg = msg || "Game Over";
            this.gameOverText.text = msg;
        }

        onClickSelectMapText() {
            this.sceneContainer.visible = false;
            this.app.gameScene.clearGame();
            this.app.startScene.show();
        }

        onClickRestartText() {
            this.sceneContainer.visible = false;
            this.app.gameScene.restart();
        }
    }

    new App().init();
</script>
</body>
</html>