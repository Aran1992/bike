<html>

<head>
    <script src="js/pixi.js"></script>
    <script src="js/planck.js"></script>
    <script src="js/utils.js"></script>
    <script src="config.js"></script>
</head>

<body>
<script>
    const {
            Application,
            Graphics,
            Container,
            Sprite,
            Texture,
            Text,
            TextStyle,
            loader,
        } = PIXI,
        TilingSprite = PIXI.extras.TilingSprite,
        resources = loader.resources, {
            Vec2,
            World,
            Edge,
            Circle,
        } = planck;

    let TEXTURE_PATH = {
        side: "images/TextureScorpiusRoad01SideSkin.png",
        top: "images/TextureScorpiusRoad01TopSkin.png",
        rider: "images/rider.png",
        bg0: "images/TextureScorpiusBackground01.png",
        bg1: "images/TextureScorpiusBackground02.png",
        bg2: "images/TextureScorpiusBackground03.png",
    };
    let JSON_PATH = {
        path: "myLaya/laya/pages/Test.scene",
    };

    function physicsPos2renderPos(pp) {
        return {
            x: pp.x * config.meter2pixel,
            y: config.sceneHeight - pp.y * config.meter2pixel
        }
    }

    // function renderPos2PhysicsPos(rp) {
    //     return {
    //         x: rp.x * config.pixel2meter,
    //         y: (config.sceneHeight - rp.y) * config.pixel2meter
    //     }
    // }

    class Game {
        init() {
            this.app = new Application({
                width: config.sceneWidth,
                height: config.sceneHeight,
                antialiasing: true,
                transparent: false,
                resolution: config.resolution,
                backgroundColor: config.backgroundColor
            });
            document.body.appendChild(this.app.view);

            this.world = new World({
                gravity: Vec2(0, config.gravity)
            });

            this.world.on('begin-contact', this.onBeginContact.bind(this));

            if (isPC()) {
                window.addEventListener("mousedown", this.onMousedown.bind(this));
            } else {
                window.addEventListener("touchstart", this.onMousedown.bind(this));
            }
            window.addEventListener("keydown", this.onKeydown.bind(this));

            loader
                .add(values(TEXTURE_PATH))
                .add(values(JSON_PATH))
                .load(this.onLoaded.bind(this));
        }

        onMousedown() {
            if (this.jumpCount < config.jumpMaxCount) {
                let velocity = this.bikeBody.getLinearVelocity();
                this.bikeBody.setLinearVelocity(Vec2(velocity.x, 0));
                this.bikeBody.applyForceToCenter(Vec2(0, config.jumpForce));
                this.bikeSprite.rotation = angle2radius(config.bikeJumpingRotation);
                this.jumping = true;
                this.jumpCount += 1;
            }
        }

        onKeydown(event) {
            switch (event.code) {
                case "ArrowUp": {
                    this.onMousedown();
                    break;
                }
                case "Space": {
                    if (this.gameStatus === "play") {
                        this.gameLoopFunc = this.pause.bind(this);
                        this.gameStatus = "pause";
                    } else if (this.gameStatus === "pause") {
                        this.gameLoopFunc = this.play.bind(this);
                        this.gameStatus = "play";
                    }
                    break;
                }
            }
        }

        onLoaded() {
            this.camera = new Container();
            this.app.stage.addChild(this.camera);

            this.createBg();

            this.gameContainer = new Container();
            this.camera.addChild(this.gameContainer);

            this.getRoadPathList().forEach(path => this.createRoad(path, TEXTURE_PATH.side, TEXTURE_PATH.top));

            this.createRider(TEXTURE_PATH.rider);

            this.createBottomMask();

            this.createFPSMessage();

            this.gameStatus = "play";
            this.gameLoopFunc = this.play.bind(this);
            this.app.ticker.add(this.gameLoop.bind(this));
        }

        onBeginContact(contact) {
            if (contact.getFixtureA().getBody() === this.bikeBody
                || contact.getFixtureB().getBody() === this.bikeBody) {
                this.jumping = false;
                this.jumpCount = 0;
            }
        }

        getRoadPathList() {
            let json = JSON.parse(resources[JSON_PATH.path].data);
            return json.child.map(data =>
                data.props.points.split(",").map((intStr, i) => {
                    let value = parseInt(intStr);
                    if (i % 2 === 0) {
                        value += data.props.x;
                    } else {
                        value += data.props.y;
                    }
                    return value;
                })
            );
        }

        createBg() {
            for (let i = 0; i < config.bgCounts; i++) {
                let container = new Container();
                this.camera.addChild(container);
                let texturePath = TEXTURE_PATH[`bg${i}`];
                let texture = resources[texturePath].texture;
                let scale = config.sceneHeight / texture.height;
                for (let i = 0; i < 2; i++) {
                    let sprite = new Sprite(texture);
                    sprite.scale.set(scale, scale);
                    sprite.position.set(i * texture.width * scale, 0);
                    container.addChild(sprite);
                }
            }
        }

        createRoad(path, sideTexturePath, topTexturePath) {
            path = [path[0], config.cliffBottomY]
                .concat(path)
                .concat([path[path.length - 2], config.cliffBottomY]);

            let road = new Container();

            let sideTexture = resources[sideTexturePath].texture;
            let sideRect = getPathRect(path);
            let side = new TilingSprite(sideTexture, sideRect.width, sideRect.height);
            side.position.set(sideRect.x, sideRect.y);
            road.addChild(side);

            let topTexture = resources[topTexturePath].texture;
            let length = path.length;
            for (let i = 2; i < length - 4; i += 2) {
                let sp = {
                        x: path[i],
                        y: path[i + 1]
                    },
                    ep = {
                        x: path[i + 2],
                        y: path[i + 3]
                    };
                let topWidth = calcPointDistance(sp, ep);
                let top = new TilingSprite(topTexture, topWidth, topTexture.height);
                top.position.set(sp.x, sp.y);
                top.rotation = calcRadius(sp, ep);
                road.addChild(top);
            }

            let edgeList = [
                {
                    sp: {x: path[0], y: path[1]},
                    ep: {x: path[2], y: path[3]},
                },
                {
                    sp: {x: path[path.length - 4], y: path[path.length - 3]},
                    ep: {x: path[path.length - 2], y: path[path.length - 1]},
                },
            ];
            edgeList.forEach(({sp, ep}) => {
                let edgeWidth = Math.abs(sp.y - ep.y);

                let canvas = document.createElement('canvas');
                canvas.width = `${edgeWidth}`;
                canvas.height = `${config.edgeHeight}`;
                let ctx = canvas.getContext('2d');
                let gradient = ctx.createLinearGradient(0, 0, 0, config.edgeHeight);
                config.edgeColorStop.forEach(({offset, opacity}) => gradient.addColorStop(offset, `rgba(0, 0, 0, ${opacity})`));
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, edgeWidth, config.edgeHeight);

                let edgeTexture = Texture.fromCanvas(canvas);
                let edge = new Sprite(edgeTexture);
                edge.position.set(sp.x, sp.y);
                console.log(edgeWidth, sp.x, sp.y, radius2angle(calcRadius(sp, ep)));
                edge.rotation = calcRadius(sp, ep);
                road.addChild(edge);

            });

            let mask = new Graphics();
            mask.beginFill();
            mask.drawPolygon(path);
            mask.endFill();
            road.mask = mask;

            road.cacheAsBitmap = true;

            this.gameContainer.addChild(road);

            path = path.map((value, i) => {
                if (i % 2 === 1) {
                    value = config.sceneHeight - value;
                }
                return value * config.pixel2meter;
            });
            let body = this.world.createBody();
            for (let i = 0; i < length - 4; i += 2) {
                let sp = {
                        x: path[i],
                        y: path[i + 1]
                    },
                    ep = {
                        x: path[i + 2],
                        y: path[i + 3]
                    };
                body.createFixture(Edge(Vec2(sp.x, sp.y), Vec2(ep.x, ep.y)), {
                    density: 0,
                    friction: 1,
                });
            }
        }

        createRider(texturePath) {
            this.bikeSprite = new Sprite(resources[texturePath].texture);
            this.bikeSprite.anchor.set(0.5, 0.5);
            this.bikeSprite.scale.set(config.riderScale, config.riderScale);

            this.bikeBody = this.world.createDynamicBody();
            this.bikeBody.createFixture(Circle(config.bikeRadius), {
                density: 1,
                friction: 1,
            });
            this.bikeBody.setPosition(Vec2(1, 33.125));

            this.gameContainer.addChild(this.bikeSprite);
            this.jumpCount = 0;
        }

        createBottomMask() {
            let canvas = document.createElement('canvas');
            canvas.width = `${config.sceneHeight}`;
            canvas.height = `${config.maskHeight}`;
            let ctx = canvas.getContext('2d');
            let gradient = ctx.createLinearGradient(0, 0, 0, config.maskHeight);
            config.maskColorStop.forEach(({offset, opacity}) => gradient.addColorStop(offset, `rgba(0, 0, 0, ${opacity})`));
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, config.sceneWidth, config.maskHeight);

            let texture = Texture.fromCanvas(canvas);
            let sprite = new Sprite(texture);
            sprite.anchor.set(0, 1);
            sprite.position.set(0, config.sceneHeight);
            this.app.stage.addChild(sprite);
        }

        createFPSMessage() {
            let style = new TextStyle({
                fill: "white",
                stroke: '#ff3300',
                strokeThickness: 1,
            });
            this.fpsMessage = new Text("FPS:0", style);
            this.app.stage.addChild(this.fpsMessage);
            this.fpsMessage.anchor.set(0, 0);
            this.fpsMessage.position.set(0, 0);
        }

        gameLoop(delta) {
            this.gameLoopFunc(delta);
        }

        play(delta) {
            this.fpsMessage.text = `FPS:${Math.floor(delta * 60)}`;

            this.world.step(delta / config.fps);

            let velocity = this.bikeBody.getLinearVelocity();
            let bikeRenderPos = physicsPos2renderPos(this.bikeBody.getPosition());
            this.bikeSprite.position.set(bikeRenderPos.x, bikeRenderPos.y);

            if (!this.jumping) {
                this.bikeSprite.rotation = -Math.atan(velocity.y / config.bikeVelocity);
            }

            this.bikeBody.setLinearVelocity(Vec2(config.bikeVelocity, velocity.y));

            let oldCameraX = this.camera.position.x;
            let oldCameraY = this.camera.position.y;

            this.camera.position.x = config.bikeLeftMargin - this.bikeSprite.position.x;

            let bikeY = this.camera.position.y + this.bikeSprite.position.y;
            if (bikeY < config.bikeCameraMinY) {
                this.camera.position.y = config.bikeCameraMinY - this.bikeSprite.position.y;
            } else if (bikeY > config.bikeCameraMaxY) {
                this.camera.position.y = config.bikeCameraMaxY - this.bikeSprite.position.y;
            }

            let cameraMoveX = this.camera.position.x - oldCameraX;
            let cameraMoveY = this.camera.position.y - oldCameraY;

            this.camera.children.forEach((child, index) => {
                child.position.x -= cameraMoveX * config.parallaxDepth[index];
                child.position.y -= cameraMoveY * config.parallaxDepth[index];
            });
        }

        pause() {
        }
    }

    new Game().init();
</script>
</body>

</html>