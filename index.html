<html>
<head>
    <script src="js/pixi.min.js"></script>
    <script src="js/planck.min.js"></script>
    <script src="js/utils.js"></script>
    <script src="base-config.js"></script>
    <script src="custom-config.js"></script>
</head>
<body>
<script>
    const
        {
            Application,
            Graphics,
            Container,
            Sprite,
            Texture,
            Text,
            TextStyle,
            loader,
        } = PIXI,
        TilingSprite = PIXI.extras.TilingSprite,
        resources = loader.resources,
        {
            Vec2,
            World,
            Edge,
            Circle,
        } = planck;

    let app;

    class MyApplication extends Application {
        constructor(args) {
            super(args);

            this.scenesContainer = this.stage;
            this.sceneWidth = args.width;
            this.sceneHeight = args.height;

            this.sceneClassTable = {
                "StartScene": StartScene,
                "GameScene": GameScene,
                "GameOverScene": GameOverScene,
            };
            this.sceneTable = {};

            this.eventTable = {};
        }

        showScene(sceneName, ...args) {
            if (this.sceneTable[sceneName] === undefined) {
                let scene = this.sceneClassTable[sceneName];
                this.sceneTable[sceneName] = new scene();
                app.scenesContainer.addChild(this.sceneTable[sceneName]);
            }
            this.sceneTable[sceneName].show(...args);
        }

        hideScene(sceneName) {
            if (this.sceneTable[sceneName]) {
                this.sceneTable[sceneName].hide();
            }
        }

        dispatchEvent(event, ...args) {
            if (this.eventTable[event]) {
                this.eventTable[event].forEach(handler => handler(...args));
            }
        }

        registerEvent(event, handler) {
            if (this.eventTable[event] === undefined) {
                this.eventTable[event] = [];
            }
            this.eventTable[event].push(handler);
        }

        unregisterEvent(event, handler) {
            if (this.eventTable[event]) {
                Utils.removeItemFromArray(this.eventTable[event], handler);
            }
        }

        loadResources(resPathList, loadedCallback) {
            resPathList = Array.from(new Set(resPathList));
            resPathList = resPathList.filter(path => resources[path] === undefined);
            loader.add(resPathList).load(loadedCallback);
        }
    }

    class Scene extends Container {
        constructor() {
            super();
            this.onCreate();
        }

        destroy() {
            this.onDestroy();
            this.parent.removeChild(this);
        }

        show(...args) {
            this.visible = true;
            this.onShow(...args);
        }

        hide() {
            this.visible = false;
            this.onHide();
        }

        onCreate() {
        }

        onDestroy() {
        }

        onShow() {
        }

        onHide() {
        }
    }

    class StartScene extends Scene {
        onCreate() {
            let textContainer = new Container();
            this.addChild(textContainer);
            let x = app.sceneWidth / 2;
            let textListHeight = config.startScene.mapText.fontSize * config.mapList.length;
            let y = (app.sceneHeight - textListHeight) / 2;
            textContainer.position.set(x, y);

            let textStyle = new TextStyle(config.startScene.mapText);
            config.mapList.forEach((mapConfig, mapIndex) => {
                let text = new Text(`MAP-${mapIndex}: ${mapConfig.showName}`, textStyle);
                text.anchor.set(0.5, 0);
                text.position.set(0, text.height * mapIndex);
                textContainer.addChild(text);
                text.interactive = true;
                text.buttonMode = true;
                text.on("pointerdown", () => this.onClickMapText(mapIndex));
            });
        }

        onClickMapText(mapIndex) {
            app.hideScene("StartScene");
            app.showScene("GameScene", mapIndex);
        }
    }

    class GameScene extends Scene {
        onCreate() {
            this.restartHandler = this.onRestart.bind(this);
            app.registerEvent("Restart", this.restartHandler);

            window.addEventListener("keydown", this.onKeydown.bind(this));

            this.gameContainer = new Container();
            this.addChild(this.gameContainer);
            let scale = app.sceneHeight / config.designHeight;
            this.gameContainer.scale.set(scale, scale);
            this.gameContainer.position.set.x = (app.sceneWidth - scale * config.designWidth) / 2;
            this.gameContainer.interactive = true;
            this.gameContainer.buttonMode = true;
            this.gameContainer.on("pointerdown", this.onClickGameContainer.bind(this));

            this.cameraContainer = new Container();
            this.gameContainer.addChild(this.cameraContainer);

            this.createBottomMask();

            this.createFPSMessage();

            this.gameStatus = "end";
            this.gameLoopFunc = this.pause.bind(this);
            app.ticker.add(this.gameLoop.bind(this));
        }

        onDestroy() {
            app.unregisterEvent("Restart", this.restartHandler);
        }

        onShow(mapIndex) {
            this.cameraContainer.removeChildren();
            this.cameraContainer.position.set(0, 0);

            this.mapIndex = mapIndex;
            this.mapConfig = config.mapList[mapIndex];
            this.bikeVelocity = this.mapConfig.bikeVelocity || config.bikeVelocity;
            this.gravity = this.mapConfig.gravity || config.gravity;
            this.jumpForce = this.mapConfig.jumpForce || config.jumpForce;

            let resPathList = this.mapConfig.texture.bg
                .concat([
                    this.mapConfig.texture.side,
                    this.mapConfig.texture.top,
                    config.mapBasePath + this.mapConfig.sceneName + ".scene",
                    config.bikeAtlasPath,
                    config.finalFlagImagePath,
                ]);
            app.loadResources(resPathList, this.onLoaded.bind(this));
        }

        onHide() {
        }

        onRestart() {
            this.onShow(this.mapIndex);
        }

        onLoaded() {
            this.world = new World({gravity: Vec2(0, this.gravity)});

            this.world.on('begin-contact', this.onBeginContact.bind(this));

            this.createBg();

            this.closeViewContainer = new Container();
            this.cameraContainer.addChild(this.closeViewContainer);

            let pathList = this.getRoadPathList();

            let lastPath = Utils.getLast(pathList);
            this.finalPoint = {
                x: (lastPath[lastPath.length - 6] + lastPath[lastPath.length - 4]) / 2,
                y: (lastPath[lastPath.length - 5] + lastPath[lastPath.length - 3]) / 2,
            };

            pathList.forEach(path => this.closeViewContainer.addChild(new Road(
                this.world,
                path,
                this.mapConfig.texture.side,
                this.mapConfig.texture.top
            )));

            this.createFinalFlag();

            this.createBike(pathList);

            this.gameStatus = "play";
            this.gameLoopFunc = this.play.bind(this);
            this.bikeBody.setLinearVelocity(Vec2(this.bikeVelocity, 0));
        }

        onBeginContact(contact) {
            if (contact.getFixtureA().getBody() === this.bikeBody
                || contact.getFixtureB().getBody() === this.bikeBody) {
                this.jumping = false;
                this.jumpCount = 0;
            }
        }

        onClickGameContainer() {
            if (this.gameStatus === "play") {
                if (this.jumpCount < config.jumpMaxCount) {
                    let velocity = this.bikeBody.getLinearVelocity();
                    this.bikeBody.setLinearVelocity(Vec2(velocity.x, 0));
                    this.bikeBody.applyForceToCenter(Vec2(0, this.jumpForce));
                    this.bikeSprite.rotation = angle2radius(config.bikeJumpingRotation);
                    this.jumping = true;
                    this.jumpCount += 1;
                }
            }
        }

        onKeydown(event) {
            switch (event.code) {
                case "ArrowUp": {
                    this.onClickGameContainer();
                    break;
                }
                case "Space": {
                    if (this.gameStatus === "play") {
                        this.gameLoopFunc = this.pause.bind(this);
                        this.gameStatus = "pause";
                    } else if (this.gameStatus === "pause") {
                        this.gameLoopFunc = this.play.bind(this);
                        this.gameStatus = "play";
                    }
                    break;
                }
            }
        }

        createBg() {
            this.mapConfig.texture.bg.forEach(texturePath => {
                let container = new Container();
                this.cameraContainer.addChild(container);
                let texture = resources[texturePath].texture;
                let scale = config.designHeight / texture.height;
                for (let i = 0; i < 2; i++) {
                    let sprite = new Sprite(texture);
                    container.addChild(sprite);
                    sprite.scale.set(scale, scale);
                    sprite.position.set(i * texture.width * scale, 0);
                }
            });
        }

        createFinalFlag() {
            let sprite = new Sprite(resources[config.finalFlagImagePath].texture);
            sprite.anchor.set(0.5, 1);
            sprite.scale.set(0.5, 0.5);
            sprite.position.set(this.finalPoint.x, this.finalPoint.y);
            this.closeViewContainer.addChild(sprite);
        }

        createBike(pathList) {
            let pp = this.renderPos2PhysicsPos({x: pathList[0][2] + config.bikeLeftMargin, y: pathList[0][3]});
            pp.x += config.bikeRadius;
            pp.y += config.bikeRadius;

            let rp = this.physicsPos2renderPos(pp);

            this.bikeSprite = new Sprite(resources[config.bikeAtlasPath].textures["0"]);
            this.closeViewContainer.addChild(this.bikeSprite);
            this.bikeSprite.anchor.set(0.5, 0.5);
            this.bikeSprite.scale.set(config.bikeScale, config.bikeScale);
            this.bikeSprite.position.set(rp.x, rp.y);

            this.bikeBody = this.world.createDynamicBody();
            this.bikeBody.createFixture(Circle(config.bikeRadius), {density: 1, friction: 1,});
            this.bikeBody.setPosition(pp);

            this.jumpCount = 0;
            this.bikeFrameCount = Utils.keys(resources[config.bikeAtlasPath].textures).length;
            this.bikeFrame = 0;
        }

        createBottomMask() {
            let canvas = Utils.createLinearGradientMask(config.designWidth, config.maskHeight, config.maskColorStop);
            let texture = Texture.fromCanvas(canvas);
            let sprite = new Sprite(texture);
            sprite.anchor.set(0, 1);
            sprite.position.set(0, config.designHeight);
            this.gameContainer.addChild(sprite);
        }

        createFPSMessage() {
            let style = new TextStyle({
                fill: "white",
                stroke: '#ff3300',
                strokeThickness: 1,
            });
            this.fpsMessage = new Text("FPS:0", style);
            this.fpsMessage.anchor.set(0, 0);
            this.addChild(this.fpsMessage);
        }

        getRoadPathList() {
            let json = JSON.parse(resources[config.mapBasePath + this.mapConfig.sceneName + ".scene"].data);
            return json.child.map(data => {
                let path = data.props.points.split(",").map((intStr, i) => {
                    let value = parseInt(intStr);
                    if (i % 2 === 0) {
                        value += data.props.x;
                    } else {
                        value += data.props.y;
                    }
                    return value;
                });
                let maxY = path[1];
                for (let i = 1; i < path.length; i += 2) {
                    if (path[i] > maxY) {
                        maxY = path[i];
                    }
                }
                let bottomY = maxY + app.sceneHeight / 3 * 2;
                path = [path[0], bottomY].concat(path);
                path = path.concat([path[path.length - 2], bottomY]);
                return path;

            });
        }

        physicsPos2renderPos(pp) {
            return {
                x: pp.x * config.meter2pixel,
                y: config.designHeight - pp.y * config.meter2pixel
            }
        }

        renderPos2PhysicsPos(rp) {
            return Vec2(
                rp.x * config.pixel2meter,
                (config.designHeight - rp.y) * config.pixel2meter
            );
        }

        gameLoop(delta) {
            this.gameLoopFunc(delta);
        }

        play(delta) {
            this.fpsMessage.text = `FPS:${Math.floor(delta * config.fps)}`;

            this.world.step(1 / config.fps);

            let velocity = this.bikeBody.getLinearVelocity();
            let bikePhysicsPos = this.bikeBody.getPosition();

            this.syncBikeSprite(velocity, bikePhysicsPos);

            this.judgeGameLose(velocity, bikePhysicsPos);

            this.judgeGameWin(bikePhysicsPos);

            this.moveCamera(velocity);
        }

        pause() {
        }

        syncBikeSprite(velocity, bikePhysicsPos) {
            let bikeRenderPos = this.physicsPos2renderPos(bikePhysicsPos);
            this.bikeSprite.position.set(bikeRenderPos.x, bikeRenderPos.y);
            if (this.gameStatus === "end") {
                this.bikeSprite.rotation = this.bikeBody.getAngle();
            } else if (!this.jumping) {
                this.bikeSprite.rotation = -Math.atan(velocity.y / velocity.x);

                this.bikeFrame += 1;
                if (this.bikeFrame >= this.bikeFrameCount) {
                    this.bikeFrame = 0;
                }
                this.bikeSprite.texture = resources[config.bikeAtlasPath].textures[`${this.bikeFrame}`];
            }
        }

        judgeGameLose(velocity, bikePhysicsPos) {
            if (this.gameStatus === "play"
                && (velocity.x <= 0 || bikePhysicsPos.y < config.bikeGameOverHeight)) {
                this.endCount = this.endCount || 0;
                this.endCount++;
                if (this.endCount >= 7) {
                    this.endCount = 0;
                    this.gameStatus = "end";

                    if (velocity.x <= 0) {
                        this.bikeBody.setLinearVelocity(Vec2(0, 0));
                        this.bikeBody.setAngularVelocity(config.bikeGameOverAngularVelocity);
                        this.bikeBody.applyForceToCenter(Vec2(-2500, 5000));
                    }

                    app.showScene("GameOverScene", "Game Over");
                }
            }
        }

        judgeGameWin(bikePhysicsPos) {
            if (this.gameStatus === "play"
                && bikePhysicsPos.x > this.renderPos2PhysicsPos(this.finalPoint).x) {
                this.gameStatus = "win";
                app.showScene("GameOverScene", "Game Win");
            }
        }

        moveCamera(velocity) {
            if (this.gameStatus === "play") {
                this.bikeBody.setLinearVelocity(Vec2(this.bikeVelocity, velocity.y));

                let oldCameraX = this.cameraContainer.position.x;
                let oldCameraY = this.cameraContainer.position.y;

                this.cameraContainer.position.x = config.bikeLeftMargin - this.bikeSprite.position.x;

                let bikeY = this.cameraContainer.position.y + this.bikeSprite.position.y;
                if (bikeY < config.bikeCameraMinY) {
                    this.cameraContainer.position.y = config.bikeCameraMinY - this.bikeSprite.position.y;
                } else if (bikeY > config.bikeCameraMaxY) {
                    this.cameraContainer.position.y = config.bikeCameraMaxY - this.bikeSprite.position.y;
                }

                let cameraMoveX = this.cameraContainer.position.x - oldCameraX;
                let cameraMoveY = this.cameraContainer.position.y - oldCameraY;

                this.cameraContainer.children.forEach((child, index) => {
                    child.position.x -= cameraMoveX * this.mapConfig.horizontalParallaxDepth[index];
                    child.position.y -= cameraMoveY * this.mapConfig.verticalParallaxDepth[index];
                });
            }
        }
    }


    class GameOverScene extends Scene {
        onCreate() {
            let mask = new Graphics()
                .beginFill(0x000000, 0.5)
                .drawRect(0, 0, app.sceneWidth, app.sceneHeight)
                .endFill();
            this.addChild(mask);

            let textContainer = new Container();
            this.addChild(textContainer);
            let textListHeight = config.gameOverScene.msgText.fontSize + config.gameOverScene.buttonText.fontSize * 2;
            let y = (app.sceneHeight - textListHeight) / 2;
            textContainer.position.set(app.sceneWidth / 2, y);

            let textStyle = new TextStyle(config.gameOverScene.msgText);
            let gameOverText = new Text("Game Over", textStyle);
            this.gameOverText = gameOverText;
            textContainer.addChild(gameOverText);
            gameOverText.anchor.set(0.5, 0);
            gameOverText.position.set(0, 0);

            textStyle = new TextStyle(config.gameOverScene.buttonText);
            let selectMapText = new Text("Select Map", textStyle);
            textContainer.addChild(selectMapText);
            selectMapText.anchor.set(0.5, 0);
            selectMapText.position.set(0, config.gameOverScene.msgText.fontSize);
            selectMapText.interactive = true;
            selectMapText.buttonMode = true;
            selectMapText.on("pointerdown", this.onClickSelectMapText.bind(this));

            let restartText = new Text("Restart", textStyle);
            textContainer.addChild(restartText);
            restartText.anchor.set(0.5, 0);
            restartText.position.set(0, config.gameOverScene.msgText.fontSize + config.gameOverScene.buttonText.fontSize);
            restartText.interactive = true;
            restartText.buttonMode = true;
            restartText.on("pointerdown", this.onClickRestartText.bind(this));
        }

        onShow(msg) {
            this.gameOverText.text = msg || "Game Over";
        }

        onClickSelectMapText() {
            app.hideScene("GameOverScene");
            app.hideScene("GameScene");
            app.showScene("StartScene");
        }

        onClickRestartText() {
            app.hideScene("GameOverScene");
            app.dispatchEvent("Restart");
        }
    }

    class Road extends Container {
        constructor(world, path, sideTexturePath, topTexturePath) {
            super();
            let rect = Utils.getPathRect(path);
            let pathInRoad = path.map((p, i) => i % 2 === 0 ? p - rect.x : p - rect.y);
            this.createSide(sideTexturePath, rect.width, rect.height);
            this.createTop(topTexturePath, pathInRoad);
            this.createEdgeMask(pathInRoad);
            this.createClipMask(pathInRoad);
            this.cacheAsBitmap = true;
            this.position.set(rect.x, rect.y);
            this.createPhysicsBody(world, path);
        }

        createSide(texturePath, width, height) {
            let texture = resources[texturePath].texture;
            let sprite = new TilingSprite(texture, width, height);
            this.addChild(sprite);
        }

        createTop(texturePath, path) {
            let texture = resources[texturePath].texture;
            for (let i = 2; i < path.length - 4; i += 2) {
                let sp = {x: path[i], y: path[i + 1]};
                let ep = {x: path[i + 2], y: path[i + 3]};
                let width = Utils.calcPointDistance(sp, ep);
                let sprite = new TilingSprite(texture, width, texture.height);
                this.addChild(sprite);
                sprite.position.set(sp.x, sp.y);
                sprite.rotation = Utils.calcRadius(sp, ep);
            }
        }

        createEdgeMask(path) {
            let edgeList = [
                {
                    sp: {x: path[0], y: path[1]},
                    ep: {x: path[2], y: path[3]},
                },
                {
                    sp: {x: path[path.length - 4], y: path[path.length - 3]},
                    ep: {x: path[path.length - 2], y: path[path.length - 1]},
                },
            ];
            edgeList.forEach(({sp, ep}) => {
                let edgeWidth = Math.abs(sp.y - ep.y);
                let canvas = Utils.createLinearGradientMask(edgeWidth, config.edgeHeight, config.edgeColorStop);
                let texture = Texture.fromCanvas(canvas);
                let sprite = new Sprite(texture);
                this.addChild(sprite);
                sprite.position.set(sp.x, sp.y);
                sprite.rotation = Utils.calcRadius(sp, ep);
            });
        }

        createClipMask(path) {
            let graphics = new Graphics();
            graphics.beginFill();
            graphics.drawPolygon(path);
            graphics.endFill();
            this.mask = graphics;
        }

        createPhysicsBody(world, path) {
            let pathInPhysics = path.map((value, i) => {
                if (i % 2 === 1) {
                    value = config.designHeight - value;
                }
                return value * config.pixel2meter;
            });

            let body = world.createBody();
            for (let i = 0; i < pathInPhysics.length - 4; i += 2) {
                let sp = {
                        x: pathInPhysics[i],
                        y: pathInPhysics[i + 1]
                    },
                    ep = {
                        x: pathInPhysics[i + 2],
                        y: pathInPhysics[i + 3]
                    };
                body.createFixture(Edge(Vec2(sp.x, sp.y), Vec2(ep.x, ep.y)), {density: 0, friction: 1,});
            }
        }
    }

    function main() {
        document.body.style.margin = "0";

        let resolution,
            appWidth,
            appHeight;

        let wwhRatio = window.innerWidth / window.innerHeight;
        let dwhRatio = config.designWidth / config.designHeight;
        if (wwhRatio >= dwhRatio) {
            resolution = window.innerHeight / config.designHeight;
            appWidth = config.designWidth;
            appHeight = config.designHeight;
        } else {
            resolution = window.innerWidth / config.designWidth;
            appWidth = config.designWidth;
            appHeight = config.designWidth / window.innerWidth * window.innerHeight;
        }

        app = new MyApplication({
            width: appWidth,
            height: appHeight,
            resolution: resolution,
            antialiasing: true,
            transparent: false,
        });
        document.body.appendChild(app.view);

        app.view.style.position = "absolute";
        app.view.style.left = (window.innerWidth - app.view.offsetWidth) / 2 + "px";
        app.view.style.top = (window.innerHeight - app.view.offsetHeight) / 2 + "px";

        app.showScene("StartScene");
    }

    main();
</script>
</body>
</html>